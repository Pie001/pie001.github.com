---
title: React 기본 학습 -1
layout: post
date:  2020-11-18 18:18
image: /assets/images/post_header.jpg
headerImage: true
#projects: true
blog: true
tag:
- react
- node.js
- dev
- programming
category: tech-note
author: pie
description: React 기본 학습 -1
---

리액트 강좌를 보면서 학습한 내용 정리용.

[리액트 무료 강좌(웹게임) - ZeroCho TV](https://www.youtube.com/watch?v=V3QsSrldHqI&list=PLcqDmjxt30RtqbStQqk-eYMK8N-1SYIFn)

# 1. 리액트 입문 도입
## 1-1. 초기 기입법
리액트js를 불러와서 날코딩할 경우.
```html
<html>
    <head>
        <!-- 리액트가 동작하는 핵심 코드 -->
        <script crossorigin src="https://unpkg.com/react@16/umd/react.development.js"></script>
        <!-- 리액트코드를 웹에 붙여주는 역할 -->
        <script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
    </head>
    <body>
        <div id="root"></div> <!-- 결과 : <div id="root"><button>Like</button></div> -->
        <script>
            const e = React.createElement;
            // 클래스 하나가 컴포넌트 하나
            class LikeButton extends React.Component {
                constructor(props){
                    super(props);
                    this.state = {
                        liked: false,
                    };
                }

                render(){
                    // 태그를 만들어 주는 함수
                    return e('button', 
                    { onClick:() => { this.setState({ liked: true })}, type: 'submit' },
                    this.state.liked === true ?  'Liked' : 'Like'); 
                    // <button onclick="() => { console.log('clicked') }" type="submit">Like</button>
                }
            }
        </script>
        <script>
            // 리액트로 컴포넌트 만든걸 리액트 돔이 렌더링(화면에 반영)해줌
            ReactDOM.render(e(LikeButton), document.querySelector('#root'));
        </script>
    </body>
</html>
```
## 1-2.  태그 기입법(JSX)
### 태그 기입법(JSX)(babel 필수) 
- 바벨을 이용하면 바벨이 JSX 문법을 createElement 로 변환시켜줌.
- 컴포넌트의 장점 : 원하는 갯수만큼 쉽게 늘릴 수 있다.
```html
<html>
    <head>
        <!-- 리액트가 동작하는 핵심 코드 -->
        <script crossorigin src="https://unpkg.com/react@16/umd/react.development.js"></script>
        <!-- 리액트코드를 웹에 붙여주는 역할 -->
        <script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
        <!-- javascript 안에 html 문법을 사용하는 등 최신 문법을 사용하기 위해 사용하는것이 babel -->
        <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    </head>
    <body>
        <div id="root"></div> <!-- 결과 : <div id="root"><button>Like</button></div> -->
        <script type="text/babel">
            class LikeButton extends React.Component {
                constructor(props){
                    super(props);
                    this.state = {
                        liked: false,
                    };
                }

                render(){
                    // 컨텐트 부분에 중괄호"{}" 를 감싸주면 내부에서 자바스크립 사용 가능.
                    return <button type="submit" onClick={() => { this.setState({ liked: true })} }>
                    { this.state.liked === true ? 'Liked' : 'Like' }
                    </button>;
                    // JSX = Javascript + XML
                }
            }
        </script>
        <script type="text/babel">
            // 닫는 괄호 필수.
            ReactDOM.render(<LikeButton />, document.querySelector('#root'));
            // ReactDOM.render(<div><LikeButton /><LikeButton /><LikeButton /><LikeButton /><LikeButton /><LikeButton /><LikeButton /></div>, document.querySelector('#root'));
        </script>
    </body>
</html>
```
## 1-3. 태그기입법으로 구구단
```html
<html>
    <head>
        <meta charset="UTF-8" />
        <title>구구단</title>
        <!-- 리액트가 동작하는 핵심 코드 -->
        <script crossorigin src="https://unpkg.com/react@16/umd/react.development.js"></script>
        <!-- 리액트코드를 웹에 붙여주는 역할 -->
        <script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
        <!-- javascript 안에 html 문법을 사용하는 등 최신 문법을 사용하기 위해 사용하는것이 babel -->
        <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    </head>
    <body>
        <div id="root"></div> <!-- 결과 : <div id="root"><button>Like</button></div> -->
        <script type="text/babel">
            class GuGuDan extends React.Component {
                // 바뀌는 속성의 요소는 여기에 넣어줌.
                state = {
                    first: Math.ceil(Math.random() * 9),
                    second: Math.ceil(Math.random() * 9),
                    value: '',
                    result: '',
                };

                onSubmit = (e) => {
                    e.preventDefault();
                    if (parseInt(this.state.value) == this.state.first * this.state.second) {
                        this.setState((prevState) => {
                            return {
                                result: prevState.value + ' 정답!',
                                first: Math.ceil(Math.random() * 9),
                                second: Math.ceil(Math.random() * 9),
                                value: '',
                            };
                        });
                        this.input.focus();

                    } else {
                        this.setState({
                            result: '땡',
                            value: '',
                        });
                        this.input.focus();
                    }
                };

                onChange = (e) => {
                    this.setState({ value: e.target.value });
                };

                onRefInput = (c) => { this.input = c; };
                render() {
                    console.log('렌더링');
                    // 리액트의 기본적인 기입방식
                    // return (
                    //     <div> 
                    //         <div>{this.state.first} 곱하기 {this.state.second} 는?</div>
                    //         <form onSubmit={this.onSubmit}>
                    //             <input type="number" value={this.state.value} onChange={this.onChange} />
                    //             <button>입력!</button>
                    //         </form>
                    //         <div>{this.state.result}</div>
                    //     </div>
                    //     );
                    // 필요없는 div를 삭제하기 위해서 아래와 같이 기입가능.
                    return (
                        <React.Fragment>
                            <div>{this.state.first} 곱하기 {this.state.second} 는?</div>
                            <form onSubmit={this.onSubmit}>
                                <input ref={ this.onRefInput } type="number" value={this.state.value} onChange={this.onChange} />
                                <button>입력!</button>
                            </form>
                            <div>{this.state.result}</div>
                        </React.Fragment>
                        );

                }
            }
        </script>
        <script type="text/babel">
            // 닫는 괄호 필수.
            ReactDOM.render(<GuGuDan />, document.querySelector('#root'));
            // ReactDOM.render(<div><LikeButton /><LikeButton /><LikeButton /><LikeButton /><LikeButton /><LikeButton /><LikeButton /></div>, document.querySelector('#root'));
        </script>
    </body>
</html>
```
### 아래 두 문법은 거의 동일함.
```
input.onchange = (e) => { console.log(e.target.value)}
```
```
input.onchange = function(e) { console.log(e.target.value) }
```
- input 태그의 `onChange={(e) => this.setState({ value: e.target.value })}` 구문은 키보드 입력을 수동으로 반영시키기 위한 구문임.
- react 는 Component 를 div로 감싸줘야 하는게 단점 (예) <div>리액트 컴포넌트</div> ) 
- 쓸모없는 div를 삭제하기 위해서는 `<React.Fragment>리액트 컴포넌트</React.Fragment>` 와 같이 사용한다.
- babel 버젼2 이상부터는 <>리액트 컴포넌트</> 로 대응 가능.

### render() 의 return 기입방식
리액트의 기본적인 기입방식

하지만 이 방식으로 기입하면 나중에 화면에서 표시될때 쓸모없는 div가 너무 많아진다.
```js
render() {
     return (
         <div> 
             <div>{this.state.first} 곱하기 {this.state.second} 는?</div>
             <form onSubmit={this.onSubmit}>
                 <input type="number" value={this.state.value} onChange={this.onChange} />
                 <button>입력!</button>
             </form>
             <div>{this.state.result}</div>
         </div>
         );
}
```
필요없는 div를 삭제하기 위해서 아래와 같이 기입가능.
```js
render() {
    return (
        <React.Fragment>
            <div>{this.state.first} 곱하기 {this.state.second} 는?</div>
            <form onSubmit={this.onSubmit}>
                <input ref={ this.onRefInput } type="number" value={this.state.value} onChange={this.onChange} />
                <button>입력!</button>
            </form>
            <div>{this.state.result}</div>
        </React.Fragment>
        );
}
```
[React Fragments 사용이유 및 사용법](https://velog.io/@lilyoh/React-Fragments-%EC%82%AC%EC%9A%A9%EC%9D%B4%EC%9C%A0-%EB%B0%8F-%EC%82%AC%EC%9A%A9%EB%B2%95)

> 리액트에서는 하나의 컴포넌트가 여러 개의 엘리먼트들을 반환한다. <br/>
> 리액트를 사용하기 위한 문법인 JSX 를 쓸 때, return 문 안에는 반드시 하나의 최상위 태그가 있어야 한다. <br/>
> 이는 리액트가 하나의 컴포넌트만을 리턴할 수 있기 때문이다.





# 

### 반복문 (map)
#### 예제 1
```js
<ul>
    {['1','2','3','4'].map((v) => {
        return (
        <li>{v}</li>
        );
    })}
</ul>
```
#### 예제 1 결과
```
1
2
3
4
```

#### 예제 2
```js
<ul>
    {[['사과', '빨강'],['바나나', '노랑'],['포도', '보라'],['귤', '오렌지']].map((v) => {
        return (
        <li>{v[0]} - {v[1]}</li>
        );
    })}
</ul>
```
#### 예제 2 결과
```
사과 - 빨강
바나나 - 노랑
포도 - 보라
귤 - 오렌지
```

### 반복문 (key)
리액트가 vue.js에 비해 반복문이 좀 깔끔하지 않다는듯.

#### 예제 1
```js
<ul>
    {[{fruit: '사과', color: '빨강'},{fruit: '바나나', color: '노랑'},{fruit: '포도', color: '보라'},{fruit: '귤', color: '오렌지'}
    ].map((v, i) => {
        return (
        <li key={v.fruit + v.color}>{i} : {v.fruit} - {v.color}</li>
        );
    })}
</ul>
```
#### 예제 1 결과
```
0 : 사과 - 빨강
1 : 바나나 - 노랑
2 : 포도 - 보라
3 : 귤 - 오렌지
```
##### 주의
- key가 선언되어 있지 않으면 콘솔에 "Warning: Each child in a list should have a unique "key" prop." 에러가 발생한다.
- 에러가 표시되는 이유는 key 는 화면에 표시는 되지 않지만 리액트가 성능최적화를 할때 사용하는 키이기 때문에 고유한 값으로 선언해 주어야 하기 때문이다.
- 리액트는 key 를 보고 같은 컴포넌트인지 아닌지 판단한다. key 값이 중복될 가능성이 있으면 어떻게 하든간에 겹치지 않는 값이 선언될 수 있도록 설정한다.(실무에서 자주 생기는 문제)

#### 자주하는 실수
**`map((v, i)` 에서 i가 index로 고유한 값이라고 생각해서 key 값에 `<li key={i}>{i} : {v.fruit} - {v.color}</li>` 이렇게 `key={i}` 하는 경우가 많은데
차후에 성능 최적화 할때 문제가 많이 생기니까 하면 안된다. i 자체를 key에 안쓰는것이 좋다.**

**리액트 개발시에는 이 key 정하는게 쓸데없이 귀찮다.**

단 요소가 추가만 되는 배열인 경우는 i를 써도 되긴 한다는듯. 하지만 추가삭제 변동이 생길 수 있는 반복문의 경우는 i 사용시에 피 보는 경우가 많은 모양.

#### 예제 1 소스 개선 방법-1-1. return 생략-중괄호 있음
화살표 함수(=>) 는 return 생략 가능함. 화살표 함수에서 중괄호가 없는건 return 의 의미하기 때문에 예제 1의 소스를 아래와 같이 return 없이 소괄호"()" 또는 괄호 없이 선언 가능.

```js
<ul>
    {[{fruit: '사과', color: '빨강'},{fruit: '바나나', color: '노랑'},{fruit: '포도', color: '보라'},{fruit: '귤', color: '오렌지'}
    ].map((v, i) => (
        <li key={v.fruit + v.color}>{i} : {v.fruit} - {v.color}</li>
    ))}
</ul>
```
#### 예제 1 소스 개선 방법-1-2. return 생략-중괄호 없음
```js
<ul>
    {[{fruit: '사과', color: '빨강'},{fruit: '바나나', color: '노랑'},{fruit: '포도', color: '보라'},{fruit: '귤', color: '오렌지'}
    ].map((v, i) => 
        <li key={v.fruit + v.color}>{i} : {v.fruit} - {v.color}</li>
    )}
</ul>
```

#### 예제 1 소스 개선방법-2. 배열 밖으로 빼내기
```js
fruits = [
    {fruit: '사과', color: '빨강'},
    {fruit: '바나나', color: '노랑'},
    {fruit: '포도', color: '보라'},
    {fruit: '귤', color: '오렌지'}
];
```
```js
<ul>
    {this.fruits.map((v, i) => 
    <li key={v.fruit + v.color}>{i} : {v.fruit} - {v.color}</li>
    )}
</ul>
```



