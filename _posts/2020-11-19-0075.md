---
title: React 기본 학습 -6. 컴포넌트 분리와 props
layout: post
date:  2020-11-18 18:18
image: /assets/images/post_header.jpg
headerImage: true
#projects: true
blog: true
tag:
- react
- node.js
- dev
- programming
category: tech-note
author: pie
description: React 기본 학습 -6. 컴포넌트 분리와 props
---

리액트 강좌를 보면서 학습한 내용 정리용.

[리액트 무료 강좌(웹게임) - ZeroCho TV](https://www.youtube.com/watch?v=V3QsSrldHqI&list=PLcqDmjxt30RtqbStQqk-eYMK8N-1SYIFn)

# 1. 컴포넌트 분리와 props

## 1) 컴포넌트 분리

### NumberBaseball.jsx (컴포넌트 분리 전)

```js
import React, { Component } from 'React'; // 이렇게 합쳐서 쓸 수 있다.

class NumberBaseball extends Component {

    render(){
        return(
            <>
              <ul>
                  {[['사과', '빨강'],['바나나', '노랑'],['포도', '보라'],['귤', '오렌지']].map((v) => {
                      return (
                      <li>{v[0]} - {v[1]}</li>
                      );
                  })}
              </ul>
            </>
        );
    }
}
```
 
### NumberBaseball.jsx (컴포넌트 분리 후)

```js
import React, { Component } from 'React'; // 이렇게 합쳐서 쓸 수 있다.

class NumberBaseball extends Component {

    fruits = [
        {fruit: '사과', color: '빨강'},
        {fruit: '바나나', color: '노랑'},
        {fruit: '포도', color: '보라'},
        {fruit: '귤', color: '오렌지'}
    ];
    
    render(){
        return(
            <>
              <ul>
                  {this.fruits.map((v, i) => 
                  <li key={v.fruit + v.color}>{i} : {v.fruit} - {v.color}</li>
                  )}
              </ul>
            </>
        );
    }
}
```

## 2) props
- HTML의 attribute와 같은 요소를 React 에서는 props 라고 한다.
- 부모 컴포넌트는 자식 컴포넌트에게 props를 상속한다.

아래 예제에서 value, index가 props에 해당한다.

```jsx
<Try value={v} index={i}/>
```

#### NumberBaseball.jsx (부모 컴포넌트)
- 반복되는 부분을 try.jsx 로 컴포넌트를 분리하여 사용함.
- map안에 자식컴포넌트 <Try />가 들어있다고 해도 무조건 key는 지정해 줘야함.

```jsx
import React, { Component } from 'React'; // 이렇게 합쳐서 쓸 수 있다.
import Try from './try';

class NumberBaseball extends Component {

    render(){
        return(
            <>
                <ul>
                    {this.fruits.map((v, i) => {
                        return (
                            <Try key={v.fruit + v.color} value={v} index={i}/>
                        );
                    })}
                </ul>
            </>
        );
    }
}
```

#### try.jsx (자식 컴포넌트)
- 부모 컴포넌트에서 전달받은 값은 this.props.{props요소이름} 으로 호출한다. 

```jsx
import React, {Component} from 'react';

class Try extends Component {
    render(){
        return(
         <li key={this.props.value.fruit + this.props.value.color}>{this.props.index} : {this.props.value.fruit} - {this.props.value.color}</li>
        )
    }
}

export default Try; // 이렇게 선언해야 다른 파일에서 불러올 수 있음.
```

- 부모-자식-손자-증손자 이렇게 서로서로 props 주고받다보면 복잡해지기 쉬우므로 redux, context (은행역할) 같은걸 사용함.
- React 자체는 context가 있고 context를 좀더 복잡한 일을 할 수 있도록 만든게 redux. redux도 내부적으론 Context를 사용함.

# 2. React의 주석

```
{/* */}
```

# 3. 메서드 바인딩
화살표 함수"()=>{}" 를 사용하지 않으면 this 호출을 못함.

### 1) 화살표 함수 사용
각 함수의 bind(this) 를 자동으로 해 주는 역할.

(예) `this.onSubmitForm = this.onSubmitForm.bind(this);` 를 화살표 함수 `onSubmitForm = () => {}` 를 사용하면 일일이 기입하지 않아도 됨)
```
onSubmitForm = () => {
    // 안에서 this 사용가능
};
```
### 2) 화살표 함수 사용안함
```
onSubmitForm () {
    // 안에서 this 사용불가
};
```
- 예전 React 문법 사용시에는 위와 같이 사용했고, 이걸 사용하기 위해 바인드를 일일이 해줘야했음.
- React 는 초창기부터 지금까지 문법 변화가 있어서 기존 React 코드를 이해하기 위해서는 이런 문법사용이 있다는 것도 알아 두어야 함.

# 4. 배열에 요소 추가할 경우에 주의할 점
#### 1) React는 array.push(1) 과 같이 push를 사용하지 않는다.
#### 이유
- React 가 render() 에서 렌더링 해 주는 기준은 참조가 바뀌어야 함. 
- 즉 예전 state 와 현재 state 가 달라야 함.

```
const arr = [];
arr.push(1);
```
위와 같이 기존 array에 push 로 1을 추가하면 참조가 변하지 않기 때문에 React 입장에선 변한게 없다고 판단하여 화면상에 변화가 발생하지 않음(render()에서 새로 그려주지 않는다는 뜻).

#### 2) 배열에 요소를 추가할때는 새로운 배열을 선언해서 기존 배열을 복사해서 넣어 주고 값을 추가한다.
```
const arr1 = [];
const arr2 = [...arr1, 1]; // "...arr1" 부분이 기존배열 arr1을 복사한다는 의미
```
배열에 값을 추가할때는 React에서 변화를 인식할 수 있도록 참조를 바꿔줄 필요가 있다.

# 5. Class 를 이용할때 this.state.xxx 를 일일이 치기 귀찮을때..
- 구조분해로 코드를 단축시키는 방법이 있음.
- 바 구조화 할당으로 간단하게 만드는 법.
- `const { result, value, tries } = this.state;` 는 Class 바로 밑에서는 선언 불가. 반드시 함수 안에서만 선언 & 적용 가능. 

#### 수정 전
```jsx
class NumberBaseball extends Component {
    state = {
        result: '',
        value : '',
        answer: getNumbers(), // [1, 3, 5, 7]
        tries: [], // 시도한 횟수. push 쓰면 안됨.
    }
    
~~ 코드 생략 ~~
    render(){
        return(
            <>
                <h1>{this.state.result}</h1>
                <form onSubmit={this.onSubmitForm}>
                    <input maxLength={4} value={this.state.value} onChange={this.onChangeInput}/>
                </form>
                <div>시도: {this.state.tries.length}</div>
                <ul>
                    {this.state.tries.map((v, i) => {
                        return (
                            <Try key={`${i + 1}차 시도 : `} tryInfo={v} />
                        );
                    })}
                </ul>
            </>
        );
    }
}
```

#### 수정 후
```jsx
class NumberBaseball extends Component {
    state = {
        result: '',
        value : '',
        answer: getNumbers(), // [1, 3, 5, 7]
        tries: [], // 시도한 횟수. push 쓰면 안됨.
    }
    
~~ 코드 생략 ~~
    render(){
        const { result, value, tries } = this.state;
        return(
            <>
                <h1>{result}</h1>
                <form onSubmit={this.onSubmitForm}>
                    <input maxLength={4} value={value} onChange={this.onChangeInput}/>
                </form>
                <div>시도: {tries.length}</div>
                <ul>
                    {tries.map((v, i) => {
                        return (
                            <Try key={`${i + 1}차 시도 : `} tryInfo={v} />
                        );
                    })}
                </ul>
            </>
        );
    }
}
```

